\documentclass[12pt, a4paper, openany]{book}
\usepackage{cmap}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english,russian]{babel}
\usepackage{gensymb} % для значков градуса в нумерации
\usepackage[left=25mm, top=20mm, right=15mm, bottom=25mm, nohead, footskip=10mm]{geometry} % размер полей

\usepackage{setspace,amssymb,amsfonts,amsmath,mathtext,cite,enumerate,float}

\usepackage[pdftex]{graphicx} % подключение рисунков
\usepackage{enumerate} % подключение списков
\graphicspath{{Images/}} % путь к рисункам
\DeclareGraphicsExtensions{.JPEG} % расширения рисунков
\usepackage[format=plain,labelsep=endash, font=small]{caption} % для подписей к рисункам

\usepackage{fancyhdr}
\usepackage{mathtools}
\usepackage{hyphenat}
\pagestyle{fancy}
\fancyhf{}
\fancyfoot[C]{\thepage} % Нумерация страниц в верхнем правом углу
\renewcommand{\headrulewidth}{0pt} % Горизонтальная черта в верхней части страницы

\renewcommand{\theenumi}{\arabic{enumi}}
\renewcommand{\theenumii}{\arabic{enumii}}
\renewcommand{\theenumiii}{\arabic{enumiii}}
\renewcommand{\labelenumi}{\arabic{enumi}.}
\renewcommand{\labelenumii}{\arabic{enumi}.\arabic{enumii}.}
\renewcommand{\labelenumiii}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}.} % вложенные нумерованные списки
\setlength{\parindent}{1cm} % отступ абзаца
\renewcommand{\thesection}{\normalsize \arabic{section}.}
\renewcommand{\thesubsection}{\normalsize \arabic{section}.\normalsize \arabic{subsection}.}
\renewcommand{\thesubsubsection}{\normalsize \arabic{section}.\normalsize \arabic{subsection}.\normalsize \arabic{subsubsection}.}
\linespread{1.3} % межстрочный интервал
    
\usepackage[hidelinks]{hyperref}

\usepackage{titlesec}

\usepackage{xcolor}
\usepackage{cancel}

\titleformat{\chapter}[display]
  {\centering\bfseries\Huge}
  {\chaptertitlename\ \thechapter}
  {20pt}
  {}

\titleformat{name=\section,numberless}[display]
  {\centering\bfseries}
  {}
  {0pt}
  {}

\usepackage{amsthm}
\usepackage{titlesec}
\usepackage{titletoc}

\usepackage{listings}

\usepackage{amssymb} % Для символа пустого квадратика
\renewcommand\qedsymbol{\ensuremath{\blacksquare}} % Закрашенный квадратик

\usepackage{amsmath}
\usepackage{tikz}
\usepackage{array}

\newtheorem*{definition}{Определение}
\newtheorem*{statement}{Утверждение}
\title{Алгоритмы теории чисел}
\author{Рыжичкин Кирилл}
\date{Февраль 2024}
\renewcommand{\cftsecfont}{\bfseries}

\begin{document}
\maketitle
\lstset{language=C++}

\tableofcontents

\newpage
\section*{Введение}
\addcontentsline{toc}{section}{Введение}{}

Мир алгоритмов теории чисел представляет собой захватывающий путь в глубины математического мира, где числа становятся не только абстрактными сущностями, но и основой для разработки эффективных алгоритмов. Теория чисел, одна из старейших областей математики, занимается изучением свойств целых чисел и их взаимосвязей. Вместе с тем, алгоритмы теории чисел играют критическую роль в современном мире, находя применение в широком спектре областей, включая криптографию, компьютерные науки, теорию игр и многое другое.

Мы начнем с основных понятий, таких как простые числа, делители, наибольший общий делитель и модульная арифметика, и постепенно углубимся в более сложные темы, такие как теорема Эйлера, китайская теорема об остатках, алгоритмы факторизации и многое другое.

% ГЛАВА 1
\chapter[Простейшие алгоритмы теории чисел]{Простейшие алгоритмы теории чисел}
\section{Простые числа}

\begin{definition}
Натуральное число p называется простым (англ. prime number), если p>1 и p не имеет натуральных делителей, отличных от 1 и p.
\end{definition}

\begin{definition}
Натуральное число n > 1 называется составным (англ. composite number), если n имеет по крайней мере один натуральный делитель, отличный от 1 и n.
\end{definition}

\noindent
Согласно определениям, множество натуральных чисел разбивается на 3 подмножества:

\begin{enumerate}
    \item Простые числа.
    \item Составные числа.
    \item Число 1, которое не причисляется ни к простым, ни к составным числам.
\end{enumerate}

Отсюда сразу возникает идея реализации интуитивно понятного алгоритма проверки числа n на простоту: если n = 1, вернуть false, иначе пройтись по всем числам от 2 до n - 1, и если ни на одно из них число не поделится, то вернуть true. Соответственно сложность такого алгоритма будет $O({n})$.

\newpage
\noindent
Посмотрим на реализацию такого простейшего алгоритма:

\begin{lstlisting}
bool isPrime(int n) {
    if (n == 1) {
        return false;
    }
    for (int i = 2; i < n; i++) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}
\end{lstlisting}

\begin{statement}
Пусть $N=a \times b$, причем $a \leq b$. Тогда $a \leq \sqrt{N} \leq \boldsymbol{b}$
\end{statement}

\begin{proof}
Eсли $a \leq b<\sqrt{N}$, то $a b \leq b^2<N$, но $a b=N$. А если $\sqrt{N}<a \leq b$, то $N<a^2 \leq a b$, но $a b=N$.
\end{proof}

Из этого следует, что если число $N$ не делится ни на одно из чисел $2,3,4, \ldots,\lfloor\sqrt{N}\rfloor$, то оно не делится и ни на одно из чисел $\lceil\sqrt{N}\rceil+1, \ldots, N-2, N-1$, так как если есть делитель больше корня (не равный $N$), то есть делитель и меньше корня (не равный 1). Поэтому в цикле for достаточно проверять числа не до $N$, а до корня. Соответственно сложность такого алгоритма будет уже $O(\sqrt{n})$:

\begin{lstlisting}
bool isPrime(int n) {
    if (n == 1) {
        return false;
    }
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}
\end{lstlisting}

Однако и этот алгоритм вовсе не оптимален и на практике применяется разве что на маленьких числах. Более оптимальные алгоритмы проверки на простоту будут расмотрены в следующих главах.

\newpage
\section{НОД и НОК двух чисел}

\begin{definition}
Наибольший общий делитель (НОД) двух натуральных чисел \(a\) и \(b\) это наибольшее натуральное число \(d\), которое делит оба числа \(a\) и \(b\) без остатка. Обозначается как \(d = \text{НОД}(a, b)\).
\end{definition}

\begin{statement}
Для любых двух натуральных чисел $a > b$ верно следующее равенство:
\begin{equation*}
\text{НОД}(a, b) = \text{НОД}(a - b, b).
\end{equation*}
\end{statement}

\begin{proof}
$n=$ \text{НОД}$(a, b) - $ наибольший среди всех общих делителей чисел $a$ и $b$, тогда $a$ $\vdots$ $n$ и $b$ $\vdots$ $n$.
Отсюда $a-b$ $\vdots$ $n$, значит, $n$ - делитель $a-b$ и $b$, он не превосходит наибольшего из всех общих делителей чисел $a-b$ и $b$, т.е. $n \leqslant m=$ $\text{НОД}$(a, b). Аналогично, рассуждая получаем, что $a-b$ $\vdots$ $m$ и $b$ $\vdots$ $m=$ $\text{НОД}$(a, b). Отсюда $a=(a-b)+b$ $\vdots$ $m$ значит, $m$ - делитель $a$ и $b$, он не превосходит наибольшего и всех общих делителей чисел $a$ и $b$, т.е. $m \leqslant n=$ \text{НОД}$(a, b)$. Таким образом получаем $m \leqslant n \leqslant m$, т.е. \text{НОД}$(a, b)=n=m=$ \text{НОД}$(a-b, b)$.
\end{proof}

\noindent
\subsection{Алгоритм Евклида}

\begin{enumerate}
  \item \textbf{Инициализация}: Начнем с двух целых чисел $a$ и $b$, где $a \geq b$.
  
  \item \textbf{Шаг 1}: Разделим $a$ на $b$ и найдем остаток от деления. Пусть остаток обозначается как $r$. То есть, $a = bq_1 + r$, где $q_1$ - частное, а $r$ - остаток.
  
  \item \textbf{Шаг 2}: Если остаток $r$ равен нулю, то \text{НОД}$(a-b, b)$ равен $b$, и алгоритм завершается.
  
  \item \textbf{Шаг 3}: Если остаток $r$ не равен нулю, заменим $a$ на $b$ и $b$ на $r$, и вернемся к \textbf{шагу 1}.
  
  \item \textbf{Шаг 4}: Повторяем процесс, пока остаток $r$ не станет равным нулю. Когда это произойдет, \text{НОД}$(a, b)$ будет равен последнему ненулевому остатку, который был получен на предыдущем шаге.
  
  \item \textbf{Вывод результата}: Когда остаток становится равным нулю, последнее значение $b$ будет искомым \text{НОД}$(a, b)$.
\end{enumerate}

Алгоритм Евклида гарантирует, что за конечное число шагов мы получим \text{НОД}$(a, b)$, так как на каждом шаге остаток уменьшается и стремится к нулю.

\newpage

\noindent
Реализация алгоритма на C++:

\begin{lstlisting}
int64_t NumberTheory::Gcd(int64_t a, int64_t b) {
  while (b != 0) {
    int64_t temp = b;
    b = a % b;
    a = temp;
  }
  return a;
}
\end{lstlisting}

\begin{definition}
Наименьшее общее кратное (НОК) двух натуральных чисел \(a\) и \(b\) это наименьшее натуральное число \(l\), которое делится на оба числа \(a\) и \(b\) без остатка. Обозначается как \(l = \text{НОК}(a, b)\).
\end{definition}

\begin{statement}
$\forall a, b \in \mathbb{N}$:
$\text{НОД}(a, b) \cdot \text{НОК}(a, b) = ab.$
\end{statement}
\begin{proof}
\noindent
Во время доказательства нам пригодится следующее простое свойство:
$$
\min (n ; m)+\max (n ; m)=n+m .
$$
\noindent
Оно верно, т.к. $\min (n, m)$ совпадает с одним из чисел $n$ или $m$, $\operatorname{a }$ $\max (n, m)$ с другим.
Запишем каноническое разложение на простые множители чисел $a$ и $b$ :
$$
a=p_1^{n_1} p_2^{n_2} \ldots p_k^{n_k} \text { и } b=p_1^{m_1} p_2^{m_2} \ldots p_k^{m_k}
$$
(возможно, что степени некоторых простых нулевые, т.е. простое число входит в разложение одного из чисел $a$ или $b$ на простые множители, но не входит в разложение второго). Запишем теперь разложение НОД $(a, b)$ и НОК $(a, b)$ :
$$
\begin{aligned}
& \text {НОД}(a, b)=p_1^{\min \left\{n_1, m_1\right\}} p_2^{\min \left\{n_2, m_2\right\}} \ldots p_k^{\min \left\{n_k, m_k\right\}} \\
& \text {НОК}(a, b)=p_1^{\max \left\{n_1, m_1\right\}} p_2^{\max \left\{n_2, m_2\right\}} \ldots p_k^{\max \left\{n_k, m_k\right\}}
\end{aligned}
$$
\noindent
То есть
$$
\begin{gathered}
\text {НОД}(a, b) \cdot \operatorname{HOK}(a, b)=\prod_{i=1}^k p_i^{\min \left\{n_i, m_i\right\}+\max \left\{n_i, m_i\right\}}=
\end{gathered}
$$
\noindent
в силу свойства, указанного в самом начале доказательства, получаем
$$
=\prod_{i=1}^k p_i^{n_i + m_i}=\prod_{i=1}^k p_i^{n_i}\prod_{i=1}^k p_i^{m_i}=a b .
$$
\end{proof}

\newpage
\noindent
Отсюда алгоритм нахождения получается элементарным:
\begin{lstlisting}
int64_t NumberTheory::Lcm(int64_t a, int64_t b) {
  return a * b / Gcd(a, b);
}
\end{lstlisting}

\section{НОД и НОК n чисел}

Алгоритм Евклида для нескольких чисел использует основное свойство наибольшего общего делителя: если $d$ делит каждое из чисел $a_1, a_2, …, a_n$, то $d$ также делит и их НОД.

\vspace{12pt}\noindentХод алгоритма Евклида для n чисел:

\begin{enumerate}
    \item \textbf{Инициализация:} Пусть у нас есть набор чисел \(a_1, a_2, \ldots, a_n\).
    \item \textbf{Нахождение НОДа для первых двух чисел:}
    \[ d_1 = \text{НОД}(a_1, a_2) \]
    \item \textbf{Обновление НОДа для следующих чисел:} \\
    Для каждого \(i = 3, 4, \ldots, n\):
    \[ d_i = \text{НОД}(d_{i-1}, a_i) \]
    \item \textbf{Конечный результат:} \\
    Наибольший общий делитель всех чисел: НОД\((a_1, a_2, \ldots, a_n) = d_n\).
\end{enumerate}

Поскольку $d_1$ является НОДом $a_1$ и $a_2$, он является делителем обоих этих чисел. Следовательно, $d_1$ делит оба числа нацело.

Когда мы переходим к следующему числу $a_i$, мы находим НОД между текущим НОДом $d_{i-1}$ и $a_i$. Это значит, что $d_{i-1}$ делит $a_i$ и $d_{i-1}$ нацело. Поскольку $d_{i-1}$ также является НОДом всех предыдущих чисел, он делит все предыдущие числа нацело. Таким образом, $d{i-1}$ делит $a_i$ и все предыдущие числа нацело.

Стало быть, после обработки всех чисел мы получаем $d_n$, который является НОДом всех чисел $a_1, a_2, …,a_n$.

\newpage
\noindent
Реализация данного алгоритма на C++:

\begin{lstlisting}
int64_t NumberTheory::Gcd(std::vector<int64_t> numbers) {
  int64_t res = numbers[0];
  for (int i = 1; i < numbers.size(); ++i) {
    res = Gcd(res, numbers[i]);
  }
  return res;
}
\end{lstlisting}

\noindent
Абсолютно аналогично получается алгоритм для нахождения НОКа нескольких чисел:

\begin{lstlisting}
int64_t NumberTheory::Lcm(std::vector<int64_t> numbers) {
  int64_t res = numbers[0];
  for (int i = 1; i < numbers.size(); ++i) {
    res = Lcm(res, numbers[i]);
  }
  return res;
}
\end{lstlisting}

\section{Расширенный алгоритм Евклида}

\begin{statement}
$\forall a, b \in \mathbb{Z} \mid \text{НОД}(a, b) = d, \exists x, y \in \mathbb{Z}: ax + by = d$.
\end{statement}

Основная идея расширенного алгоритма Евклида заключается в том, что мы можем выразить НОД двух чисел $a$ и $b$ через их линейную комбинацию, то есть такие целые числа $x$ и $y$, что $ax + by = \text{НОД}(a, b)$. Это следует из того факта, что множество всех линейных комбинаций $a$ и $b$ образует идеал в кольце $\mathbb{Z}$, а значит, содержит их НОД.

Будем считать, что у нас есть структура ExtendedEuclideanResult, которая хранит НОД(a, b), а также коэффициенты x, y, тогда расширенный алгоритм Евклида на C++ будет выглядеть так:

\newpage
\begin{lstlisting}[breaklines=true]
struct ExtendedEuclideanResult {
  ExtendedEuclideanResult(int64_t gcd, int64_t x, int64_t y) : gcd(gcd), x(x), y(y) {}
  ~ExtendedEuclideanResult() = default;

  int64_t gcd;
  int64_t x;
  int64_t y;

  friend std::ostream& operator<<(std::ostream& os, const ExtendedEuclideanResult& result) {
    os << "GCD:" << result.gcd << ",x:" << result.x << ",y:" << result.y;
    return os;
  }
};

ExtendedEuclideanResult NumberTheory::ExtEuclide(int64_t a, int64_t b) {
  int64_t x = 0, y = 1, lastX = 1, lastY = 0, temp;
  while (b != 0) {
    int64_t quotient = a / b;
    int64_t remainder = a % b;

    a = b;
    b = remainder;

    temp = x;
    x = lastX - quotient * x;
    lastX = temp;

    temp = y;
    y = lastY - quotient * y;
    lastY = temp;
  }

  return ExtendedEuclideanResult(a, lastX, lastY);
}
\end{lstlisting}

\section{Линейные диофантовы уравнения с двумя
неизвестными}

Пусть нам дано уравнение $ax + by = c$, где $a, b, c \in \mathbb{Z}$.

Заметим, что левая часть уравнения делится на $\text{НОД}(a, b)$, значит $c$ обязано делиться на $\text{НОД}(a, b)$, чтобы решение существовало.

Если $\text{НОД}(a, b) \mid c$, то поделим обе части на этот НОД, получим новое уравнение $a^{'}x + b^{'}y = c^{'}$, где $\text{НОД}(a^{'}, b^{'}) = 1$.

Пусть мы угадали какое-то решение $(x_0, y_0)$ этого уравнения. Так как $a^{'}x_0 + b^{'}y_0 = c^{'}$, то для любой пары $(x, y)$ получим $a^{'}x + b^{'}y = a^{'}x_0 + b^{'}y_0$. Получим $a^{'}(x - x_0) = b^{'}(y-y_0)$.

Так как $\text{НОД}(a^{'}, b^{'}) = 1$, то $b \mid x - x_0$, обозначим $x - x_0 = kb^{'}$, тогда $y - y_0 = ka^{'}$.

\noindent
В итоге получаем множество решений $(x, y) = (x_0 + kb^{'}, y_0 - ka^{'})$, где $k \in \mathbb{Z}$.

Угадать решение уравнения $a^{'}x + b^{'}y = c^{'}$, где $\text{НОД}(a^{'}, b^{'}) = 1$ можно с помощью алгоритма Евклида. Сначала найдем решение $(x_0, y_0)$ уравнения $a^{'}x + b^{'}y = 1$ (это можно сделать в силу утверждения со стр. 9), тогда $(cx_0, cy_0)$ - решение уравнения $a^{'}x + b^{'}y = c^{'}$.

\subsection{Алгоритм решения линейного диофантова уравнения с двумя неизвестными}

\begin{enumerate}
    \item \textbf{Проверка существования решений:} Проверям, делится ли правая часть уравнения на $\text{НОД}(a, b)$, если да - идём дальше, если нет - решения отсутствуют.
    \item \textbf{Нахождение одного частного решения:} Применяя алгоритм Евклида, находим частное решение $(x_0, y_0)$ уравнения $ax + by = c$.
    \item \textbf{Нахождение общего решения:} Общее решение линейного диофантова уравнения может быть представлено в виде \\
    \[(x_0 + \frac{b}{\text{НОД}(a, b)} t, y_0 - \frac{a}{\text{НОД}(a, b)} t), t \in \mathbb{Z}\]
\end{enumerate}

\newpage
\noindent
Так выглядит реализация данного алгоритма на C++:

\begin{lstlisting}[breaklines=true]
struct DiophantusResult {
  DiophantusResult() = default;
  DiophantusResult(int64_t x, int64_t y, int64_t k_1, int64_t k_2) : x(x), y(y), k_1(k_1), k_2(k_2), s("good") {}
  ~DiophantusResult() = default;

  int64_t x = 0;
  int64_t y = 0;
  int64_t k_1 = 0;
  int64_t k_2 = 0;
  std::string s = "none";

  friend std::ostream& operator<<(std::ostream& os, const DiophantusResult& result) {
    std::string sign_1 = "+";;
    std::string sign_2 = "-";

    if (result.k_1 < 0) {
      sign_1 = "-";
    }

    if (result.k_2 < 0) {
      sign_2 = "+";
    }

    if (result.s == "good") {
      os << "(x,y)=" << "(" << result.x << sign_1 << std::abs(result.k_1) << "t," << result.y << sign_2 << std::abs(result.k_2) << "t)";
    }

    else {
      os << "None";
    }

    return os;
  }
};

DiophantusResult NumberTheory::Diophantus(int64_t a, int64_t b, int64_t c) {
  ExtendedEuclideanResult result = ExtEuclide(a, b);

  int64_t g = result.gcd;

  if (c % g != 0) {
    return DiophantusResult(); 
  }

  int64_t k = c / g;

  return DiophantusResult(k * result.x, k * result.y, b / g, a / g);
}
\end{lstlisting}

\section{Количество/сумма делителей числа}

Алгоритм нахожденгия количества/суммы делителей числа можно реализовать элементарным перебором делителей. Сложность такого алгоритма будет $\text{O}(\sqrt{n})$. 

\noindent
Рассмотрим такие алгоритмы:

\begin{lstlisting}[breaklines=true]
int64_t NumberTheory::DivisorsCount(int64_t n) {
  n = std::abs(n);
  int64_t count = 0;
  for (int64_t i = 1; i <= static_cast<int64_t>(std::sqrt(n)); ++i) {
    if (n % i == 0) {
      count += (i == n / i) ? 1 : 2;
    }
  }
  return count;
}
\end{lstlisting}

\newpage
\begin{lstlisting}[breaklines=true]
int64_t NumberTheory::DivisorsSum(int64_t n) {
  for (int64_t i = 1; i <= static_cast<int64_t>(std::sqrt(n)); ++i) {
    if (n % i == 0) {
      sum += i;
      if (i != n / i) {
        sum += n / i;
      }
    }
  }
  return sum;
}
\end{lstlisting}

Однакого количество/сумма делителей любого числа легко выражается через его разложение на простые множители. Соответственно если мы реализуем факторизацию со сложностью, меньшей чем $\text{O}(\sqrt{n})$, то получим более оптимальный алгоритм. Такие факторизации будут расмотрены в слудющих главах, а пока будем считать, что у нас есть такой алгоритм разложения на простые множители и получим формулы количества и суммы делителей числа.

\noindent
Пусть дано целое число $ n $ с разложением на простые множители:
\[n = p_1^{a_1} \times p_2^{a_2} \times \ldots \times p_k^{a_k},\]
\noindent
где $ p_1, p_2, \ldots, p_k $ - простые числа (не обязательно различные), а $ a_1, a_2, \ldots, a_k $ - их показатели степени.

\begin{statement}
Пусть $\tau(n)$ обозначает количество положительных делителей числа $n$. Тогда $\tau(n) = (a_1 + 1) \times (a_2 + 1) \times \ldots \times (a_k + 1)$.
\end{statement}

\begin{proof}
Каждый делитель числа $ n $ имеет вид:
\[ d = p_1^{b_1} \times p_2^{b_2} \times \ldots \times p_k^{b_k},\]
\noindent
где $ 0 \leq b_i \leq a_i $ для $ i = 1, 2, \ldots, k $. Чтобы получить все делители числа $ n $, мы можем взять каждый из $ k $ простых множителей и выбрать любую комбинацию показателей степени от 0 до $ a_i $. Таким образом, общее количество делителей числа $ n $:
\begin{equation}\tau(n) = (a_1 + 1) \times (a_2 + 1) \times \ldots \times (a_k + 1)\end{equation}.
\end{proof}

\newpage

\begin{statement}
Пусть $\sigma(n)$ обозначает сумму положительных делителей числа $n$. Тогда \begin{equation}
\sigma(n) = \frac{{p_1^{a_1+1} - 1}}{{p_1 - 1}} \cdot \frac{{p_2^{a_2+1} - 1}}{{p_2 - 1}} \cdot \ldots \cdot \frac{{p_k^{a_k+1} - 1}}{{p_k - 1}}
\end{equation}
\end{statement}

\begin{proof}
Cумма делителей числа \( n \) может быть выражена как произведение всех возможных комбинаций делителей:
\[
\sigma(n) = (1 + p_1 + p_1^2 + \ldots + p_1^{a_1}) \cdot (1 + p_2 + p_2^2 + \ldots + p_2^{a_2}) \cdot \ldots \cdot (1 + p_k + p_k^2 + \ldots + p_k^{a_k})
\]
\noindent
Cумма геометрической прогрессии имеет вид:
\[
1 + p^1 + p^2 + \ldots + p^m = \frac{{p^{m+1} - 1}}{{p - 1}}
\]
\noindent
Подставляя это обратно в наше уравнение, получаем требуемое равенство.
\end{proof}

\section{Степень вхождения простого числа в факториал}

\begin{statement}
Пусть $\text{ord}_p(n!)$ обозначает степень вхождения простого числа $p$ в $n!$. Тогда
\begin{equation}\text{ord}_p(n!) = \sum_{i=1}^{\infty} \left\lfloor \frac{n}{p^i} \right\rfloor\end{equation}
\end{statement}

\begin{proof}
\[n! = 1 \times 2 \times 3 \times \ldots \times (n-1) \times n\]

Каждый $p$-ый член этого произведения делится на $p$, т.е. даёт +1 к ответу, количество таких членов равно $\left\lfloor \frac{n}{p} \right\rfloor.$

Далее, заметим, что каждый $p^2$-ый член этого ряда делится на $p^2$, т.е. даёт ещё +1 к ответу (учитывая, что $p$ в первой степени уже было учтено до этого); количество таких членов равно $\left\lfloor \frac{n}{p^2} \right\rfloor$.

И так далее, каждый $p^i$-ый член ряда даёт +1 к ответу, а количество таких членов равно $\left\lfloor \frac{n}{p^i} \right\rfloor.$

Таким образом, \[\text{ord}_p(n!) = \left\lfloor\frac{n}{p}\right\rfloor + \left\lfloor\frac{n}{p^2}\right\rfloor + \ldots + \left\lfloor\frac{n}{p^i}\right\rfloor + \ldots\].
\end{proof}

\newpage

\noindent
Реализация данного алгоритма на C++:
\begin{lstlisting}[breaklines=true]
int64_t NumberTheory::PrimePowerInFactorial(int64_t n, int64_t p) {
	int64_t res = 0;
	while (n) {
		n /= p;
		res += n;
	}
	return res;
}
\end{lstlisting}

\section{Решето Эратосфена}

Решето Эратосфена --- достаточно эффективный алгоритм для нахождения всех простых чисел в отрезке от 1 до $n$ за $\text{O}(nloglogn)$. Ход алгоритма:

\begin{enumerate}
    \item Начинаем с списка чисел от 2 до $n$.
    \item Отмечаем первое простое число в списке (2) как простое.
    \item Зачеркниваем все кратные двойке числа в списке (кроме самой двойки).
    \item Переходим к следующему незачеркнутому числу в списке (3), отмечаем его как простое.
    \item Зачеркиваем все кратные тройке числа в списке (кроме самой тройки).
    \item Повторяем этот процесс для каждого незачеркнутого числа в списке, пока не достигнем $\sqrt{n}$.
    \item Все оставшиеся незачеркнутые числа в списке считаются простыми.
\end{enumerate}

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
\hline
\textcolor{gray}{} & 2 & 3 & \textcolor{gray}{4} & 5 & \textcolor{gray}{6} & 7 & \textcolor{gray}{8} & \textcolor{gray}{9} & \textcolor{gray}{10} \\
\hline
11 & \textcolor{gray}{12} & 13 & \textcolor{gray}{14} & \textcolor{gray}{15} & \textcolor{gray}{16} & 17 & \textcolor{gray}{18} & 19 & \textcolor{gray}{20} \\
\hline
\textcolor{gray}{21} & \textcolor{gray}{22} & 23 & \textcolor{gray}{24} & \textcolor{gray}{25} & \textcolor{gray}{26} & \textcolor{gray}{27} & \textcolor{gray}{28} & 29 & \textcolor{gray}{30} \\
\hline
31 & \textcolor{gray}{32} & \textcolor{gray}{33} & \textcolor{gray}{34} & \textcolor{gray}{35} & \textcolor{gray}{36} & 37 & \textcolor{gray}{38} & \textcolor{gray}{39} & \textcolor{gray}{40} \\
\hline
41 & \textcolor{gray}{42} & 43 & \textcolor{gray}{44} & \textcolor{gray}{45} & \textcolor{gray}{46} & 47 & \textcolor{gray}{48} & \textcolor{gray}{49} & \textcolor{gray}{50} \\
\hline
\textcolor{gray}{51} & \textcolor{gray}{52} & 53 & \textcolor{gray}{54} & \textcolor{gray}{55} & \textcolor{gray}{56} & \textcolor{gray}{57} & \textcolor{gray}{58} & 59 & \textcolor{gray}{60} \\
\hline
61 & \textcolor{gray}{62} & \textcolor{gray}{63} & \textcolor{gray}{64} & \textcolor{gray}{65} & \textcolor{gray}{66} & 67 & \textcolor{gray}{68} & \textcolor{gray}{69} & \textcolor{gray}{70} \\
\hline
71 & \textcolor{gray}{72} & 73 & \textcolor{gray}{74} & \textcolor{gray}{75} & \textcolor{gray}{76} & \textcolor{gray}{77} & \textcolor{gray}{78} & 79 & \textcolor{gray}{80} \\
\hline
\textcolor{gray}{81} & \textcolor{gray}{82} & 83 & \textcolor{gray}{84} & \textcolor{gray}{85} & \textcolor{gray}{86} & \textcolor{gray}{87} & \textcolor{gray}{88} & 89 & \textcolor{gray}{90} \\
\hline
\textcolor{gray}{91} & \textcolor{gray}{92} & \textcolor{gray}{93} & \textcolor{gray}{94} & \textcolor{gray}{95} & \textcolor{gray}{96} & 97 & \textcolor{gray}{98} & \textcolor{gray}{99} & \textcolor{gray}{100} \\
\hline
\end{tabular}
\caption{Иллюстрация решета Эратосфена}
\end{table}

\newpage
\noindent
Реализация данного алгоритма на C++:

\begin{lstlisting}[breaklines=true]
std::vector<int64_t> NumberTheory::SieveOfEratosthenes(int64_t n) {
  std::vector<bool> isPrime(n + 1, true);
  std::vector<int64_t> primes;

  for (int p = 2; p * p <= n; p++) {
    if (isPrime[p] == true) {
      for (int64_t i = p * p; i <= n; i += p)
        isPrime[i] = false;
    }
  }

  for (int64_t p = 2; p <= n; p++) {
    if (isPrime[p])
      primes.push_back(p);
  }

  return primes;
}
\end{lstlisting}

% ГЛАВА 1
\chapter[Модульная арифметика]{Модульная арифметика}
\section{Сравнения по модулю}

\begin{definition}
Пусть $a$, $b$, и $m$ --- целые числа, где $m > 0$. Мы говорим, что $a$ сравнимо с $b$ по модулю $m$, если $m$ делит разность $a - b$, обозначается как \[a \equiv b \pmod{m}\]
\end{definition}

\subsection{Свойства сравнений}

\begin{enumerate}
    \item Если $a \equiv b \pmod{m}$ и $b \equiv c \pmod{m}$, то $a \equiv c \pmod{m}$.
    \item Если $a \equiv b \pmod{m}$, то $ak \equiv bk \pmod{m}$ для любого целого числа $k$.
    \item Если $a \equiv b \pmod{m}$ и $c \equiv d \pmod{m}$, то $a + c \equiv b + d \pmod{m}$.
    \item Если $a \equiv b \pmod{m}$ и $c \equiv d \pmod{m}$, то $ac \equiv bd \pmod{m}$.
    \item Если $a \equiv b \pmod{m}$, то $a^k \equiv b^k \pmod{m}$ для любого натурального числа $k$.
\end{enumerate}

\section{Обратный элемент в кольце вычетов по модулю}

\begin{definition}
Пусть $a$ и $m$ - целые числа, причем $m > 1$. Целое число $a^{-1}$ называется обратным по модулю $m$ элементом к $a$, если выполняется условие:
\[aa^{-1} \equiv 1 \pmod{m}\]
\end{definition}

\newpage
\subsection{Существование и единственность}

\begin{statement}
Обратный по модулю $n$ элемент к $a$ существует тогда и только тогда, когда $a$ и $n$ взаимно просты.
\end{statement}

\begin{proof} 
($\Rightarrow$) Предположим, что существует обратный по модулю $n$ элемент к $a$. Тогда существует такое целое число $b$, что $ab \equiv 1 \pmod{n}$. Это означает, что существует такое целое число $k$, что $ab = 1 + kn$. Таким образом, $1 = ab - kn$, что означает, что $1$ является линейной комбинацией $a$ и $n$. Следовательно, $a$ и $n$ взаимно просты по определению.

($\Leftarrow$) Теперь предположим, что $a$ и $n$ взаимно просты. По расширенному алгоритму Евклида существуют такие целые числа $x$ и $y$, что $ax + ny = 1$. Заметим, что $ax \equiv 1 \pmod{n}$. Таким образом, $x$ является обратным по модулю $n$ элементом к $a$.
\end{proof}

\subsection{Нахождение обратного элемента}

Пусть нам надо найти обратный к $a$ элемент по модулю $m$, то есть мы ищем $x$ такой, что \[ax \equiv 1 \pmod{m}\] 
Рассмотрим линейное диофантово уравнение $at+my=1$, левая часть при делении на $m$ даёт остаток $at$, а правая --- $1$, то есть чтобы найти обратный к $a$ элемент, нам достаточно найти коэффициент $t$ с помощью расширенного алгоритма Евклида и взять его по модулю $m$.

\noindent
Реализация на C++:

\begin{lstlisting}[breaklines=true]
int64_t NumberTheory::ModInverse(int64_t a, int64_t m) {
  // no solutions 
  if (a == 0 || Gcd(m, a) != 1) {
    return 0;
  }

  ExtendedEuclideanResult euclide = ExtEuclide(a, m);
  int64_t result = ((euclide.x % m) + m) % m;

  return result;
}
\end{lstlisting}

\section{Линейные сравнения с неизвестной}

\begin{definition}
Линейное сравнение по модулю $m$ представляет собой уравнение вида $ax \equiv b \pmod{m}$, где $a, b, m \in \mathbb{Z}, m > 0$, а $x$ - неизвестная переменная.
\end{definition}

Обозначим $d = \text{НОД}(a, m)$. Так как $ax$ и $b$ дают одинаковые остатки по модулю $m$, то $b$ обязано делиться на $d$. Если $b$ не делится на $d$, то сравнение решений не имеет.
Если же $b$ делится на $d$, то разделим обе части сравнения на $d$ и перейдём к сравнению 
\begin{equation}a^{'}x \equiv b^{'} \pmod{m^{'}}\end{equation}
Так как $\text{НОД}(a^{'}, m^{'}) = 1$, то существует элемент $a^{'-1}$, для которого верно
\begin{equation}a^{'}a^{'-1} \equiv 1 \pmod{m^{'}}\end{equation}
Умножим сравние (2.1) на $a^{'-1}$, тогда
\begin{equation}x \equiv a^{'-1}b^{'} \pmod{m^{'}}\end{equation}
Соответсвенно решением исходного сравнения будут являться все $x$, дающие по модулю $m^{'}$ остаток $a^{'-1}b^{'}$, и находящеся в кольце $\mathbb{Z}/m\mathbb{Z}$.
Окончательно получаем:
\begin{equation}
x \in \{a^{'-1}b^{'} + km^{'}\, |\, k \in \mathbb{Z},\, 0 <= k < d\}
\end{equation}

\noindent
Реализация алгоритма решения линеного сравнения на C++:

\begin{lstlisting}[breaklines=true]
std::vector<int64_t> NumberTheory::SolveLinearCongruence(int64_t a, int64_t b, int64_t m) {
  int64_t d = Gcd(a, m);
  if (b % d != 0)
    return std::vector<int64_t>{ 0 }; // no solutions
  a /= d;
  b /= d;
  m /= d;
  int64_t x_0 = ModInverse(a, m) * b % m;
  std::vector<int64_t> result{ x_0 };
  for (int64_t k = 1; k < d; ++k) {
    result.push_back(x_0 + k * m);
  }
  return result;
}
\end{lstlisting}

\end{document}

